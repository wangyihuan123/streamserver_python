# streamserver_python

## Task:

1. Create a server that streams your webcam stream on a TCP server. The server can also record that stream to a file.
2. Create a UI to control that server functionality which will be start/stop & record to file.

## How to run
1. start server
```
cd src
sudo python3 main.py
```
Then you should see an urgly UI panel.

2. start stream engine from UI by press the "start stream engine" button 

3. start client
```
cd script
python3 client.py
```
Then you should see a window showing the stream video generated by opencv.

## Notes:

1. Work environment:   
- Linux(ubuntu 16.04) or MacOS(10.10)  
- python3.6+  
- opencv  
- tkinter  

2. If you stop the stream engine and want to restart stream again, you probably need to restart client and reconnect to stream server as well. This project is a stream server, so I ignored some features at client side.   

3. The stream can be saved as an AVI video in the directory of `record_data` after press `start recording` button. 

4. Currently the stream server is only designed to service one client. Probably will add multiple clients later after the test environments had been built.

5. Circle-CI for continuous integration has been deployed on this project. For detail, you can check this project ci status on circle-ci website [here](https://app.circleci.com/pipelines/github/wangyihuan123/streamserver_python/)


## The main reasons for refactoring ver 0.0.1 :
1. In ver 0.0.1, UI and tcp server are implemented seperately. Need to find a better way to combine them and build the communication path between them.
2. In ver 0.0.1, the stream display via opencv was quite expensive because it is in the thread of socket where tcp server is trying the best to receive messages.
3. The server in ver 0.0.1 was a single file with a single class. It is hard to extend and debug based on this structure.
4. Tkinter which is the core of UI, need to be in the main thread of a process. Check [here](https://stackoverflow.com/questions/14694408/runtimeerror-main-thread-is-not-in-main-loop)
5. Loosely coupling is better than tight coupling when you need to dispatch a complex problem to small tasks.


## Design ideas:
1. There are two types of threads in this refactoring: thread for engine and threads for each controller. 
    - main thread for GUI (see the reason [here](https://stackoverflow.com/questions/14694408/runtimeerror-main-thread-is-not-in-main-loop))
    - one thread for stream engine (the main feature)
    - one thread for opencv_image_controller for debug and image display
    - one thread for terminal_controller for debug 
1. Stream engine focuses on the main feature of this project which is video stream on tcp connection  while controllers, including its derived controllers such as opencvController or guiController, focuses on application management. 
2. Stream engine and all the controllers are connected via registeration (keep a  proxy reference of each other via weakref) which can make the memory management easier.
3. Stream engine can call the methods of all the controllers directly if it is neccesary. This can implement a fake publish/subscribe notification mechanism in an easy way. 
3. But controllers can NOT any method in stream engine as it may cause some concurrency issues, such as race condition, shared resource lock. And it also may effect the performance of engine for receiving the video stream.
3. Instead, the communication from controllers to engine are based on queue buffer which can be shared among the threads. The post_command message in controllers is desgined based on this.  
3. Using state machine to switch the role of stream engine, e.g., in `idle` state, engine only receive commands from controlllers and while `run` state engine does a lot of things. This can be easily extended as the business grow.
3. Using ThreadedController class can manage the threads of controllers better, like when to start controller threads, or thread exception handler. Moreover, it separates the threads management outside of the base controller class.
3. For release version, just simply remove the registrations of opencv and terminal controllers can have a stable and better performance application.

## TODO:
1. create another engine to handle the post-process of images so that stream engine can really focus on message receiving.
2. test case should be based on some input data(video or images) instead of a webcam
3. keep refactoring, keep testing


## Release

====================================
**ver 0.0.3**

Features:
1. add shutdown button on GUI to exit application normally
2. add start/stop buttons to control the stream engine
3. setup circle-ci for continuous integration
4. setup pytest for unit test
5. add terminal controller for extra debug and control methods

Bugs fix:
1. wrong dir and wrong names of the recording video

====================================  
**ver 0.0.2**

re-write the project in python

Todo:
refactoring, comments and testing

====================================  
**ver 0.0.1**

Implemented basic functionalities , but has many limitations:

1. Tested task 1 and task 2 seperately. run server.py/client.py for task 1 and run gui.py for task 2.
2. For task 2, only finished UI panel
